<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake AI - Q-Learning</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --success-color: #27ae60;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        header {
            background: var(--primary-color);
            color: white;
            padding: 15px 20px;
            text-align: center;
        }
        
        h1 {
            font-size: 2em;
            margin-bottom: 5px;
        }
        
        .subtitle {
            font-size: 1em;
            opacity: 0.9;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            padding: 20px;
        }
        
        .game-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .settings-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
        }
        
        .settings-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }
        
        .settings-group {
            margin-bottom: 10px;
        }
        
        .settings-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            font-size: 13px;
            color: #2c3e50;
            cursor: pointer;
        }
        
        .settings-group label:hover {
            color: #3498db;
        }
        
        .settings-group input, .settings-group select {
            width: 100%;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .file-input-group {
            display: flex;
            gap: 8px;
            grid-column: 1 / -1;
        }
        
        .file-input-group input {
            flex: 1;
        }
        
        .file-input-wrapper {
            flex: 1;
            display: block;
            font-weight: 600;
            font-size: 13px;
            color: #2c3e50;
        }

        .file-input-wrapper input {
            width: 100%;
            margin-top: 5px;
            display: block;
        }
        
        /* Styles d'accessibilit√© */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        /* Focus visible pour l'accessibilit√© */
        input:focus, button:focus {
            outline: 2px solid #3498db;
            outline-offset: 2px;
        }
        
        /* Am√©lioration des boutons pour l'accessibilit√© */
        button:focus-visible {
            outline: 2px solid #3498db;
            outline-offset: 2px;
            transform: translateY(-1px);
        }
        
        .game-board-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        
        .grid {
            display: inline-grid;
            gap: 2px;
            background: #bdc3c7;
            padding: 2px;
            border-radius: 5px;
            margin: 10px auto;
            border: 2px solid #7f8c8d;
            position: relative;
        }
        
        .cell {
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            border-radius: 3px;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .cell.snake-head { 
            background: var(--secondary-color); 
            color: white;
        }
        .cell.snake-body { 
            background: #87CEEB; 
        }
        .cell.green-apple { 
            background: var(--success-color); 
            animation: pulse 1.5s infinite;
        }
        .cell.red-apple { 
            background: var(--danger-color); 
            animation: pulse 1.5s infinite;
        }
        .cell.wall { 
            background: #7f8c8d; 
            color: white;
        }
        .cell.empty { 
            background: white; 
        }
        
        .spectrum-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background: rgba(128, 128, 128, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin: 10px 0;
        }
        
        button {
            padding: 10px 12px;
            border: none;
            border-radius: 6px;
            background: var(--primary-color);
            color: white;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        button.primary { background: var(--secondary-color); }
        button.success { background: var(--success-color); }
        button.danger { background: var(--danger-color); }
        button.warning { background: var(--warning-color); }
        
        /* Styles pour les boutons activ√©s */
        button.active {
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
            transform: translateY(-1px);
        }
        
        button.active::after {
            content: "‚úì";
            position: absolute;
            top: 2px;
            right: 5px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .mode-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 10px 0;
        }
        
        .mode-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .parameters-section {
            margin-top: 10px;
        }
        
        .parameters-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 10px;
        }
        
        .info-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .info-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 10px 0;
        }
        
        .stat-card {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            border-left: 4px solid var(--secondary-color);
        }
        
        .stat-value {
            font-size: 1.4em;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .stat-label {
            font-size: 0.8em;
            color: #7f8c8d;
            margin-top: 2px;
        }
        
        .q-learning-info {
            background: #e8f4f8;
            border-left: 4px solid var(--secondary-color);
            padding: 12px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 12px;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 10px 0;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }
        
        .discovered-objects {
            max-height: 150px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.4;
            margin-top: 10px;
        }
        
        .object-item {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid #eee;
        }
        
        .object-wall {
            color: var(--danger-color);
            font-weight: bold;
        }
        
        .history-display {
            max-height: 120px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.3;
            margin-top: 8px;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #f1f2f6;
            border-radius: 4px;
            margin-top: 8px;
            font-size: 12px;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .status-value {
            font-weight: bold;
            color: var(--primary-color);
        }
        
        /* Styles pour le responsive */
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .mode-buttons {
                grid-template-columns: 1fr;
            }
            
            .settings-content {
                grid-template-columns: 1fr;
            }
            
            .parameters-grid {
                grid-template-columns: 1fr;
            }
            
            .status-bar {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üêç Snake AI - Q-Learning</h1>
            <p class="subtitle">Apprentissage par Renforcement - Version Web</p>
        </header>
        
        <div class="main-content">
            <div class="game-section">
                <!-- Panneau des param√®tres -->
                <div class="settings-panel">
                    <div class="settings-header" onclick="toggleSettings()">
                        <h2>‚öôÔ∏è Param√®tres du Jeu</h2>
                        <span id="settings-arrow">‚ñº</span>
                    </div>
                    <div class="settings-content" id="settings-content">
                        <!-- Section des modes de jeu -->
                        <div class="mode-section">
                            <div class="settings-group">
                                <!-- <label>Mode de jeu:</label> -->
                                <div class="mode-buttons">
                                    <button type="button" class="primary" id="learning-mode" onclick="setMode('Learning')">üéì Learning</button>
                                    <button type="button" class="success" id="game-mode" onclick="setMode('Game')">üéÆ Game</button>
                                    <button type="button" class="warning" id="dontlearn-mode" onclick="setMode('Dontlearn')">üé≤ Dontlearn</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Section des param√®tres -->
                        <div class="parameters-section">
                            <div>
                                <div class="settings-group">
                                    <label for="sessions">Sessions: <span id="sessions-value">10</span></label>
                                    <input type="range" id="sessions" name="sessions" min="1" max="100" value="10" onchange="updateSessionsValue()">
                                </div>
                                
                                <div class="settings-group">
                                    <label for="board-size">Taille du plateau: <span id="size-value">10</span></label>
                                    <input type="range" id="board-size" name="board-size" min="8" max="20" value="10" onchange="updateSizeValue()">
                                </div>
                            </div>
                            <div>
                                <div class="settings-group">
                                    <label for="green-apples">Pommes vertes: <span id="green-value">2</span></label>
                                    <input type="range" id="green-apples" name="green-apples" min="1" max="5" value="2" onchange="updateGreenValue()">
                                </div>
                                
                                <div class="settings-group">
                                    <label for="red-apples">Pommes rouges: <span id="red-value">1</span></label>
                                    <input type="range" id="red-apples" name="red-apples" min="0" max="3" value="1" onchange="updateRedValue()">
                                </div>
                            </div>
                        </div>

                        <!-- Section fichiers -->
                        <div class="file-input-group">
                            <label class="file-input-wrapper">
                                Chemin du mod√®le:
                                <input type="text" id="model-path" name="model-path" 
                                    placeholder="Ex: model.json"
                                    aria-describedby="model-path-help">
                                <div id="model-path-help" class="sr-only">
                                    Entrez le chemin du fichier mod√®le √† charger ou sauvegarder
                                </div>
                            </label>
                            <button type="button" onclick="loadModel()" aria-label="Charger le mod√®le">üìÇ Charger</button>
                            <button type="button" onclick="saveModel()" aria-label="Sauvegarder le mod√®le">üíæ Sauvegarder</button>
                        </div>
                    </div>
                    
                    <!-- Barre de status -->
                    <div class="status-bar">
                        <div class="status-item">
                            <span>Status:</span>
                            <span class="status-value" id="status">Pr√™t</span>
                        </div>
                        <div class="status-item">
                            <span>Mode:</span>
                            <span class="status-value" id="mode-display">Learning</span>
                        </div>
                        <div class="status-item">
                            <span>Vitesse:</span>
                            <span class="status-value" id="speed-display">200</span>ms
                        </div>
                        <div class="status-item">
                            <span>Session:</span>
                            <span class="status-value" id="session">1/10</span>
                        </div>
                    </div>
                </div>
                
                <!-- Plateau de jeu -->
                <div class="game-board-container">
                    <h2>üéØ Plateau de Jeu</h2>
                    <div id="game-container">
                        <p>Initialisation du jeu...</p>
                    </div>
                </div>
                
                <!-- Contr√¥les de jeu -->
                <div class="info-card">
                    <h2>üéÆ Contr√¥les du Jeu</h2>
                    <div class="controls">
                        <button type="button" class="success" onclick="resetGame()">üîÑ Nouvelle Partie</button>
                        <button type="button" class="primary" id="start-button" onclick="startTraining()">üöÄ Start Training</button>
                        <button type="button" class="warning" id="pause-button" onclick="pauseTraining()">‚è∏Ô∏è Pause</button>
                        <button type="button" class="danger" id="stop-button" onclick="stopGame()">‚èπÔ∏è Stop</button>
                        <button type="button" id="step-button" onclick="stepTraining()">üìù Step</button>
                        <button type="button" id="manual-mode-button" onclick="toggleManualMode()">üëÜ Manual Mode</button>
                        <button type="button" id="spectrum-button" onclick="toggleSpectrum()">üëª Spectre</button>
                        <button type="button" onclick="changeSpeed('slower')">üê¢ Ralentir</button>
                        <button type="button" onclick="changeSpeed('faster')">‚ö° Acc√©l√©rer</button>
                    </div>
                </div>
            </div>
            
            <div class="info-section">
                                
                <!-- Q-Learning Agent -->
                <div class="info-card">
                    <h2>üß† Q-Learning Agent</h2>
                    <div class="q-learning-info">
                        <p><strong>Learning Rate:</strong> 0.007</p>
                        <p><strong>Discount Factor:</strong> 0.00995</p>
                        <p><strong>Score Rate:</strong> 2e-05</p>
                        <p><strong>Heatmap Rate:</strong> -0.5</p>
                    </div>
                    
                    <h3>üìñ L√©gende</h3>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #3498db;"></div>
                            <span>T√™te (H)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #87CEEB;"></div>
                            <span>Corps (S)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #27ae60;"></div>
                            <span>Pomme verte (G)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #e74c3c;"></div>
                            <span>Pomme rouge (R)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #7f8c8d;"></div>
                            <span>Mur (W)</span>
                        </div>
                    </div>
                </div>

                <!-- Statistiques -->
                <div class="info-card">
                    <h2>üìä Statistiques</h2>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value" id="score">0</div>
                            <div class="stat-label">Score</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="steps">0</div>
                            <div class="stat-label">Steps</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="max-length">3</div>
                            <div class="stat-label">Longueur Max</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="exploration-rate">0.200</div>
                            <div class="stat-label">Exploration</div>
                        </div>
                    </div>
                </div>
                
                <!-- Q-Values Actuelles -->
                <div class="info-card">
                    <h2>üìà Q-Values Actuelles</h2>
                    <div id="q-values-display" style="font-family: monospace; font-size: 12px; line-height: 1.4;">
                        UP => W : 0.00<br>
                        DOWN => S : 0.00<br>
                        LEFT => S : 0.00<br>
                        RIGHT => S : 0.00
                    </div>
                    <div style="margin-top: 8px; font-size: 12px;">
                        <strong>Action choisie:</strong> <span id="action-chosen">-</span>
                    </div>
                </div>
                
                <!-- Objets D√©couverts -->
                <div class="info-card">
                    <h2>üîç Objets D√©couverts</h2>
                    <div style="font-size: 11px; color: #666; margin-bottom: 5px;">
                        Taille plateau d√©tect√©e: <span id="board-size-display">0x0</span>
                    </div>
                    <div id="objects-display" class="discovered-objects">
                        Aucun objet d√©couvert
                    </div>
                </div>
                
                <!-- Historique des Sessions -->
                <div class="info-card">
                    <h2>üìã Historique des Sessions</h2>
                    <div id="history-display" class="history-display">
                        Aucune session termin√©e
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =============================================================================
        // IMPL√âMENTATION FID√àLE DE VOTRE PROJET PYTHON EN JAVASCRIPT
        // =============================================================================

        // Variables globales
        let game = null;
        let agent = null;
        let autoPlayInterval = null;
        let manualMode = false;
        let gameSpeed = 200;
        let currentSession = 1;
        let totalSessions = 10;
        let lengthHistory = [];
        let showSpectrum = false;
        let settingsVisible = true;
        let isTraining = false;

        // Configuration actuelle
        let config = {
            mode: 'Learning',
            boardSize: 10,
            greenApples: 2,
            redApples: 1,
            sessions: 10
        };

        // =============================================================================
        // CLASSE BOARD - Reproduction fid√®le de board.py
        // =============================================================================

        class Board {
            constructor(size = 10, nb_r_app = 1, nb_g_app = 2) {
                this.size = size;
                this.grid = Array(size).fill().map(() => Array(size).fill('0'));
                this.snake = this.initialize_snake();
                this.green_apples = [];
                this.nb_g_app = nb_g_app;
                this.red_apples = [];
                this.nb_r_app = nb_r_app;
                this.place_apples();
                this.snake_dir = this.random_or_advantageous_direction();
                this.score = 0;
                this.steps = 0;
                this.max_length = 3;
                this.initial_score = 3;
                this.max_length_reached = 3;
            }

            initialize_snake() {
                const start_x = Math.floor(Math.random() * (this.size - 2)) + 1;
                const start_y = Math.floor(Math.random() * (this.size - 4)) + 1;
                return [
                    [start_x, start_y],
                    [start_x, start_y + 1],
                    [start_x, start_y + 2]
                ];
            }

            random_or_advantageous_direction() {
                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                const advantages = {};
                directions.forEach(d => {
                    advantages[d] = this.evaluate_direction(d);
                });
                
                if (Object.values(advantages).every(value => value === 0)) {
                    return directions[Math.floor(Math.random() * directions.length)];
                }
                
                return directions.reduce((best, current) => 
                    advantages[current] > advantages[best] ? current : best
                );
            }

            evaluate_direction(direction) {
                const [head_x, head_y] = this.snake[0];
                const [dx, dy] = direction;
                const new_head = [head_x + dx, head_y + dy];

                if (!(0 <= new_head[0] && new_head[0] < this.size && 0 <= new_head[1] && new_head[1] < this.size)) {
                    return -100; // Mur
                }
                if (this.snake.some(segment => segment[0] === new_head[0] && segment[1] === new_head[1])) {
                    return -50; // Corps du serpent
                }
                if (this.green_apples.some(apple => apple[0] === new_head[0] && apple[1] === new_head[1])) {
                    return 20; // Pomme verte
                }
                if (this.red_apples.some(apple => apple[0] === new_head[0] && apple[1] === new_head[1])) {
                    return -10; // Pomme rouge
                }
                return 0; // Case vide
            }

            reset() {
                this.snake = this.initialize_snake();
                this.snake_dir = this.random_or_advantageous_direction();
                this.score = this.initial_score;
                this.steps = 0;
                this.max_length = 3;
                this.green_apples = [];
                this.red_apples = [];
                this.place_apples();
            }

            place_apples() {
                this.green_apples = Array(this.nb_g_app).fill().map(() => this.random_empty_cell());
                this.red_apples = Array(this.nb_r_app).fill().map(() => this.random_empty_cell());
            }

            random_empty_cell() {
                while (true) {
                    const x = Math.floor(Math.random() * this.size);
                    const y = Math.floor(Math.random() * this.size);
                    
                    const notInSnake = !this.snake.some(segment => segment[0] === x && segment[1] === y);
                    const notInGreen = !this.green_apples.some(apple => apple[0] === x && apple[1] === y);
                    const notInRed = !this.red_apples.some(apple => apple[0] === x && apple[1] === y);
                    
                    if (notInSnake && notInGreen && notInRed) {
                        return [x, y];
                    }
                }
            }

            update() {
                const [head_x, head_y] = this.snake[0];
                const [dx, dy] = this.snake_dir;
                const new_head = [head_x + dx, head_y + dy];

                // V√©rifier collision avec le corps
                if (this.snake.some(segment => segment[0] === new_head[0] && segment[1] === new_head[1])) {
                    return "Hit Snake Body";
                }

                // V√©rifier collision avec les murs
                if (!(0 <= new_head[0] && new_head[0] < this.size && 0 <= new_head[1] && new_head[1] < this.size)) {
                    return "Game Over";
                }

                // V√©rifier les pommes vertes
                const greenAppleIndex = this.green_apples.findIndex(apple => 
                    apple[0] === new_head[0] && apple[1] === new_head[1]
                );
                if (greenAppleIndex !== -1) {
                    this.snake.unshift(new_head);
                    this.green_apples.splice(greenAppleIndex, 1);
                    this.green_apples.push(this.random_empty_cell());
                    this.score += 1;
                    this.max_length = Math.max(this.max_length, this.snake.length);
                    this.max_length_reached = Math.max(this.max_length_reached, this.snake.length);
                    return "Ate Green Apple";
                }

                // V√©rifier les pommes rouges
                const redAppleIndex = this.red_apples.findIndex(apple => 
                    apple[0] === new_head[0] && apple[1] === new_head[1]
                );
                if (redAppleIndex !== -1) {
                    this.snake.pop();
                    if (this.snake.length === 0) {
                        return "Game Over";
                    }
                    this.red_apples.splice(redAppleIndex, 1);
                    this.red_apples.push(this.random_empty_cell());
                    this.score -= 10;
                    return "Ate Red Apple";
                }

                // D√©placement normal
                this.snake.unshift(new_head);
                this.snake.pop();
                return "Moved";
            }

            get_state() {
                const [head_x, head_y] = this.snake[0];
                return [
                    this.cell_info(head_x - 1, head_y),
                    this.cell_info(head_x + 1, head_y),
                    this.cell_info(head_x, head_y - 1),
                    this.cell_info(head_x, head_y + 1)
                ];
            }

            cell_info(x, y) {
                if (!(0 <= x && x < this.size && 0 <= y && y < this.size)) {
                    return "W";
                }
                if (this.snake.some(segment => segment[0] === x && segment[1] === y)) {
                    return "S";
                }
                if (this.green_apples.some(apple => apple[0] === x && apple[1] === y)) {
                    return "G";
                }
                if (this.red_apples.some(apple => apple[0] === x && apple[1] === y)) {
                    return "R";
                }
                return "0";
            }

            render() {
                this.grid = Array(this.size).fill().map(() => Array(this.size).fill('0'));
                
                this.green_apples.forEach(([gx, gy]) => {
                    this.grid[gx][gy] = 'G';
                });
                
                this.red_apples.forEach(([rx, ry]) => {
                    this.grid[rx][ry] = 'R';
                });
                
                this.snake.forEach(([x, y], i) => {
                    this.grid[x][y] = i === 0 ? 'H' : 'S';
                });
            }
        }

        // =============================================================================
        // CLASSE QLEARNINGAGENT - Reproduction fid√®le de agent.py
        // =============================================================================

        class QLearningAgent {
            constructor(actions, verbose = false) {
                this.actions = actions;
                this.score_rate = 2e-05;
                this.heatmap_rate = -0.5;
                this.learning_rate = 0.007;
                this.discount_factor = 0.00995;
                this.min_exploration = 0.01;
                this.exploration_rate = 0.2;
                this.exploration_decay = 0.0999;
                this.q_table = {};
                this.discovered_objects = {};
                this.verbose = verbose;
                this.steps = 0;
                this.dontlearn_enabled = true;
                this.position_history = [];
                this.current_position = [0, 0];
                this.history_length = 3;
                this.board_size = [0, 0];
                this.wall_obj = "";
                this.wall_up = false;
                this.wall_left = false;
                this.max_x = 0;
                this.max_y = 0;
                this.locked_x = 0;
                this.locked_y = 0;
                this.mini_size = [7, 7];
            }

            dontlearn() {
                this.dontlearn_enabled = false;
                this.exploration_rate = 1.0;
            }

            update_position(action, state) {
                let [x, y] = this.current_position;
                switch(action) {
                    case "UP": x -= 1; break;
                    case "DOWN": x += 1; break;
                    case "LEFT": y -= 1; break;
                    case "RIGHT": y += 1; break;
                }

                this.current_position = [x, y];
                this.position_history.push([x, y]);

                if (this.position_history.length > this.history_length) {
                    this.position_history.shift();
                }

                this.detect_board(state);
                this.adjust_positions(state);
            }

            detect_board(state) {
                if (this.board_size[0] > this.mini_size[0] && this.board_size[1] > this.mini_size[1]) {
                    return;
                }

                this.detect_walls(state);

                if (!this.wall_obj) return;

                const [obj_up, obj_down, obj_left, obj_right] = state;

                // D√©tection des murs
                if (obj_up === this.wall_obj) {
                    this.current_position = [1, this.current_position[1]];
                    this.wall_up = true;
                }
                if (obj_up !== this.wall_obj && this.current_position[0] <= 0) {
                    this.current_position = [1, this.current_position[1]];
                }

                if (obj_left === this.wall_obj) {
                    this.current_position = [this.current_position[0], 1];
                    this.wall_left = true;
                }
                if (obj_left !== this.wall_obj && this.current_position[1] < 0) {
                    this.current_position = [this.current_position[0], 1];
                }

                // D√©tection de la taille du plateau
                if (this.locked_x < 3 && obj_down === this.wall_obj && this.wall_up) {
                    if (this.current_position[0] + 1 > this.mini_size[0]) {
                        if (this.max_x === this.current_position[0] + 1) {
                            this.locked_x += 1;
                        }
                        this.max_x = this.current_position[0] + 1;
                        this.wall_up = false;
                    }
                } else if (this.locked_x >= 3 && obj_down === this.wall_obj) {
                    this.current_position = [this.max_x - 2, this.current_position[1]];
                }

                if (this.locked_y < 3 && obj_right === this.wall_obj && this.wall_left) {
                    if (this.current_position[1] + 1 > this.mini_size[1]) {
                        if (this.max_y === this.current_position[1] + 1) {
                            this.locked_y += 1;
                        }
                        this.max_y = this.current_position[1] + 1;
                        this.wall_left = false;
                    }
                } else if (this.locked_y >= 3 && obj_right === this.wall_obj) {
                    this.current_position = [this.current_position[0], this.max_y - 2];
                }

                if (this.locked_x >= 3 && this.max_x > 0 && this.board_size[0] !== this.max_x) {
                    this.board_size[0] = this.max_x;
                }

                if (this.locked_y >= 3 && this.max_y > 0 && this.board_size[1] !== this.max_y) {
                    this.board_size[1] = this.max_y;
                }
            }

            detect_walls(state) {
                const [obj_up, , obj_left] = state;
                const reward_up = this.discovered_objects[obj_up] || 0;
                const reward_left = this.discovered_objects[obj_left] || 0;
                const reward_wall_obj = this.discovered_objects[this.wall_obj] || 0;

                if (!this.wall_obj) {
                    this.wall_obj = reward_up < reward_left ? obj_up : obj_left;
                } else {
                    if (reward_up < reward_wall_obj) {
                        this.wall_obj = obj_up;
                    }
                    if (reward_left < reward_wall_obj) {
                        this.wall_obj = obj_left;
                    }
                }
            }

            adjust_positions(state) {
                if (this.board_size[0] <= this.mini_size[0] || this.board_size[1] <= this.mini_size[1]) {
                    return;
                }

                const [max_x, max_y] = this.board_size;
                const [obj_up, obj_down, obj_left, obj_right] = state;

                let [new_x, new_y] = this.current_position;

                if (obj_up === this.wall_obj) {
                    new_x = 1;
                } else if (this.current_position[0] < 1) {
                    new_x = 0;
                }

                if (obj_left === this.wall_obj) {
                    new_y = 1;
                } else if (this.current_position[1] < 1) {
                    new_y = 0;
                }

                if (obj_down === this.wall_obj) {
                    new_x = max_x - 2;
                } else if (this.current_position[0] > max_x - 2) {
                    new_x = max_x - 1;
                }

                if (obj_right === this.wall_obj) {
                    new_y = max_y - 2;
                } else if (this.current_position[1] > max_y - 2) {
                    new_y = max_y - 1;
                }

                const dx = new_x - this.current_position[0];
                const dy = new_y - this.current_position[1];

                if (dx !== 0 || dy !== 0) {
                    this.position_history = this.position_history.map(([x, y]) => [x + dx, y + dy]);
                }

                this.current_position = [new_x, new_y];

                this.position_history = this.position_history.map(([x, y]) => [
                    Math.max(0, Math.min(x, max_x - 1)),
                    Math.max(0, Math.min(y, max_y - 1))
                ]);

                this.current_position = [
                    Math.max(0, Math.min(this.current_position[0], max_x - 1)),
                    Math.max(0, Math.min(this.current_position[1], max_y - 1))
                ];
            }

            adjust_history_length(reward) {
                if (reward > 0) {
                    this.history_length += 1;
                } else if (reward < -1) {
                    this.history_length = Math.max(0, this.history_length - 1);
                    if (this.position_history.length > 0) {
                        this.position_history.shift();
                    }
                }
            }

            reset_history() {
                this.position_history = [];
                this.history_length = 3;
                this.wall_up = false;
                this.wall_left = false;
            }

            learn(state, action, reward, next_state) {
                if (!this.dontlearn_enabled) return;

                const obj = state[this.actions.indexOf(action)];
                this.discovered_objects[obj] = Math.max(
                    this.discovered_objects[obj] || -Infinity,
                    reward
                );

                if (!this.q_table[state]) {
                    this.q_table[state] = {};
                    this.actions.forEach(a => this.q_table[state][a] = 0);
                }

                const next_q_values = this.q_table[next_state] || {};
                const best_next_action = Object.keys(next_q_values).length > 0 ? 
                    Object.keys(next_q_values).reduce((a, b) => next_q_values[a] > next_q_values[b] ? a : b) : 
                    this.actions[0];

                const td_target = reward + this.discount_factor * (next_q_values[best_next_action] || 0);
                const td_error = td_target - this.q_table[state][action];
                this.q_table[state][action] += this.learning_rate * td_error * (1 - this.exploration_rate);

                this.adjust_history_length(reward);
            }

            handle_new_objects(state, action, reward) {
                if (!this.dontlearn_enabled) return;

                const obj = state[this.actions.indexOf(action)];
                const previous_reward = this.discovered_objects[obj] !== undefined ? this.discovered_objects[obj] : "Inconnu";

                if (this.discovered_objects[obj] === undefined || reward < this.discovered_objects[obj]) {
                    this.discovered_objects[obj] = reward;
                    if (this.verbose) {
                        console.log(`Objet ${obj} mis √† jour: Ancienne r√©compense = ${previous_reward}, Nouvelle r√©compense = ${reward}`);
                    }
                }
            }

            decay_exploration() {
                this.exploration_rate = Math.max(
                    this.min_exploration,
                    this.exploration_rate * this.exploration_decay
                );
            }

            get_q_values(state) {
                return this.q_table[state] || this.actions.reduce((acc, action) => {
                    acc[action] = 0;
                    return acc;
                }, {});
            }

            get_position_history() {
                return this.position_history;
            }

            compute_free_space(position) {
                const queue = [position];
                const visited = new Set([position.toString()]);
                let count = 0;

                while (queue.length > 0) {
                    const [x, y] = queue.shift();
                    count += 1;

                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    for (const [dx, dy] of directions) {
                        const new_pos = [x + dx, y + dy];
                        const new_pos_str = new_pos.toString();

                        if (0 <= new_pos[0] && new_pos[0] < this.board_size[0] &&
                            0 <= new_pos[1] && new_pos[1] < this.board_size[1] &&
                            !visited.has(new_pos_str) &&
                            !this.position_history.some(pos => pos[0] === new_pos[0] && pos[1] === new_pos[1]) &&
                            new_pos.toString() !== this.wall_obj.toString()) {
                            queue.push(new_pos);
                            visited.add(new_pos_str);
                        }
                    }
                }

                return count;
            }

            compute_heatmap() {
                const heatmap = {};
                this.position_history.forEach(pos => {
                    const key = pos.toString();
                    heatmap[key] = (heatmap[key] || 0) + 1;
                });
                return heatmap;
            }

            choose_action(state, training = true) {
                if (!this.dontlearn_enabled) {
                    return this.actions[Math.floor(Math.random() * this.actions.length)];
                }

                const unknown_objects = state.filter(obj => this.discovered_objects[obj] === undefined);

                if (unknown_objects.length > 0) {
                    const chosen_object = unknown_objects[Math.floor(Math.random() * unknown_objects.length)];
                    const action_index = state.indexOf(chosen_object);
                    const action = this.actions[action_index];
                    this.update_position(action, state);
                    return action;
                } else {
                    const heatmap = this.compute_heatmap();
                    const best_actions = [];
                    const action_scores = {};

                    this.actions.forEach((action, i) => {
                        const obj = state[i];
                        let [x, y] = this.current_position;

                        switch(action) {
                            case "UP": x -= 1; break;
                            case "DOWN": x += 1; break;
                            case "LEFT": y -= 1; break;
                            case "RIGHT": y += 1; break;
                        }

                        const reward = this.discovered_objects[obj] || 0;
                        const free_space = this.compute_free_space([x, y]);
                        const visit_penalty = (heatmap[[x, y].toString()] || 0) * this.learning_rate;
                        let score = reward + free_space * this.score_rate + visit_penalty;

                        if (free_space < 2) {
                            score -= 50;
                        }

                        action_scores[action] = score;
                    });

                    const max_score = Math.max(...Object.values(action_scores));
                    Object.keys(action_scores).forEach(action => {
                        if (action_scores[action] === max_score) {
                            best_actions.push(action);
                        }
                    });

                    const action = best_actions[Math.floor(Math.random() * best_actions.length)];
                    this.update_position(action, state);
                    return action;
                }
            }
        }

        // =============================================================================
        // FONCTIONS DE GESTION DE L'INTERFACE
        // =============================================================================

        function initializeGame() {
            config.boardSize = parseInt(document.getElementById('board-size').value);
            config.greenApples = parseInt(document.getElementById('green-apples').value);
            config.redApples = parseInt(document.getElementById('red-apples').value);
            config.sessions = parseInt(document.getElementById('sessions').value);
            totalSessions = config.sessions;

            game = new Board(config.boardSize, config.redApples, config.greenApples);
            agent = new QLearningAgent(["UP", "DOWN", "LEFT", "RIGHT"]);

            if (config.mode === 'Dontlearn') {
                agent.dontlearn();
            }

            updateButtonStates();
            updateDisplay();
            renderGame();
        }

        function renderGame() {
            const container = document.getElementById('game-container');
            container.innerHTML = '';
            
            game.render();
            
            const grid = document.createElement('div');
            grid.className = 'grid';
            grid.style.gridTemplateColumns = `repeat(${game.size}, 25px)`;
            
            for (let i = 0; i < game.size; i++) {
                for (let j = 0; j < game.size; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    switch (game.grid[i][j]) {
                        case 'H': 
                            cell.className += ' snake-head';
                            cell.textContent = 'H';
                            break;
                        case 'S': 
                            cell.className += ' snake-body';
                            cell.textContent = '';
                            break;
                        case 'G': 
                            cell.className += ' green-apple';
                            cell.textContent = '';
                            break;
                        case 'R': 
                            cell.className += ' red-apple';
                            cell.textContent = '';
                            break;
                        case 'W': 
                            cell.className += ' wall';
                            cell.textContent = 'W';
                            break;
                        default: 
                            cell.className += ' empty';
                            cell.textContent = '';
                    }
                    
                    grid.appendChild(cell);
                }
            }
            
            container.appendChild(grid);

            // Afficher le spectre si activ√©
            if (showSpectrum) {
                drawPositionHistory(grid);
            }
        }

        function drawPositionHistory(grid) {
            const positionHistory = agent.get_position_history();
            
            positionHistory.forEach(([x, y]) => {
                const dot = document.createElement('div');
                dot.className = 'spectrum-dot';
                dot.style.left = `${y * 25 + 12}px`;
                dot.style.top = `${x * 25 + 12}px`;
                grid.appendChild(dot);
            });
        }

        function updateDisplay() {
            // Mise √† jour des statistiques
            document.getElementById('score').textContent = game.score;
            document.getElementById('steps').textContent = game.steps;
            document.getElementById('max-length').textContent = game.max_length_reached;
            document.getElementById('session').textContent = `${currentSession}/${totalSessions}`;
            document.getElementById('status').textContent = getStatusText();
            document.getElementById('mode-display').textContent = config.mode;
            document.getElementById('speed-display').textContent = gameSpeed;
            document.getElementById('exploration-rate').textContent = agent.exploration_rate.toFixed(3);

            // Mise √† jour des Q-values
            const state = game.get_state();
            const qValues = agent.get_q_values(state.toString());
            let qValuesText = '';
            const stateMapping = {
                "UP": state[0],
                "DOWN": state[1],
                "LEFT": state[2],
                "RIGHT": state[3]
            };
            
            Object.keys(stateMapping).forEach(action => {
                qValuesText += `${action} => ${stateMapping[action]} : ${qValues[action].toFixed(2)}<br>`;
            });
            document.getElementById('q-values-display').innerHTML = qValuesText;

            // Mise √† jour des objets d√©couverts
            updateObjectsDisplay();

            // Mise √† jour de l'historique
            updateHistoryDisplay();

            // Mise √† jour de la taille du plateau d√©tect√©e
            document.getElementById('board-size-display').textContent = 
                `${agent.board_size[0]}x${agent.board_size[1]}`;
        }

        function updateObjectsDisplay() {
            const objectsContainer = document.getElementById('objects-display');
            const discoveredObjects = agent.discovered_objects;
            
            if (Object.keys(discoveredObjects).length === 0) {
                objectsContainer.innerHTML = 'Aucun objet d√©couvert';
                return;
            }

            let objectsHTML = '';
            Object.entries(discoveredObjects).forEach(([obj, reward]) => {
                const isWall = obj === agent.wall_obj;
                objectsHTML += `
                    <div class="object-item ${isWall ? 'object-wall' : ''}">
                        <span>${obj}</span>
                        <span>${reward}</span>
                        ${isWall ? '<span>-Wall</span>' : ''}
                    </div>
                `;
            });
            objectsContainer.innerHTML = objectsHTML;
        }

        function updateHistoryDisplay() {
            const historyContainer = document.getElementById('history-display');
            
            if (lengthHistory.length === 0) {
                historyContainer.innerHTML = 'Aucune session termin√©e';
                return;
            }

            let historyHTML = '';
            lengthHistory.forEach((score, index) => {
                historyHTML += `Session ${index + 1}: Longueur max = ${score}<br>`;
            });
            historyContainer.innerHTML = historyHTML;
        }

        function getStatusText() {
            if (!autoPlayInterval) return 'Arr√™t√©';
            if (manualMode) return 'Mode Manuel';
            return 'En cours';
        }

        function toggleSettings() {
            settingsVisible = !settingsVisible;
            const content = document.getElementById('settings-content');
            const arrow = document.getElementById('settings-arrow');
            
            if (settingsVisible) {
                content.style.display = 'grid';
                arrow.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                arrow.textContent = '‚ñ∂';
            }
        }

        // =============================================================================
        // GESTION DES √âTATS DES BOUTONS
        // =============================================================================

        function updateButtonStates() {
            // Modes de jeu
            document.getElementById('learning-mode').classList.toggle('active', config.mode === 'Learning');
            document.getElementById('game-mode').classList.toggle('active', config.mode === 'Game');
            document.getElementById('dontlearn-mode').classList.toggle('active', config.mode === 'Dontlearn');
            
            // Boutons de contr√¥le
            document.getElementById('start-button').classList.toggle('active', isTraining);
            document.getElementById('pause-button').classList.toggle('active', autoPlayInterval !== null && !isTraining);
            document.getElementById('stop-button').classList.toggle('active', !isTraining && currentSession > 1);
            document.getElementById('manual-mode-button').classList.toggle('active', manualMode);
            document.getElementById('spectrum-button').classList.toggle('active', showSpectrum);
            document.getElementById('step-button').classList.toggle('active', !autoPlayInterval && !manualMode);
        }

        // =============================================================================
        // FONCTIONS DE CONTR√îLE
        // =============================================================================

        function startTraining() {
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
            }
            
            isTraining = true;
            autoPlayInterval = setInterval(runGameStep, gameSpeed);
            document.getElementById('status').textContent = 'Entra√Ænement en cours';
            updateButtonStates();
        }

        function pauseTraining() {
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
                isTraining = false;
            }
            document.getElementById('status').textContent = 'En pause';
            updateButtonStates();
        }

        function stopGame() {
            pauseTraining();
            currentSession = 1;
            lengthHistory = [];
            initializeGame();
            document.getElementById('status').textContent = 'Arr√™t√©';
            updateButtonStates();
        }

        function stepTraining() {
            pauseTraining();
            runGameStep();
            updateButtonStates();
        }

        function resetGame() {
            stopGame();
            initializeGame();
        }

        function toggleManualMode() {
            manualMode = !manualMode;
            if (manualMode) {
                pauseTraining();
                document.getElementById('status').textContent = 'Mode Manuel';
            } else {
                document.getElementById('status').textContent = 'Arr√™t√©';
            }
            updateButtonStates();
        }

        function toggleSpectrum() {
            showSpectrum = !showSpectrum;
            renderGame();
            updateButtonStates();
        }

        function changeSpeed(direction) {
            if (direction === 'faster') {
                gameSpeed = Math.max(50, gameSpeed - 50);
            } else {
                gameSpeed = Math.min(1000, gameSpeed + 50);
            }
            
            if (autoPlayInterval) {
                pauseTraining();
                startTraining();
            }
            
            document.getElementById('speed-display').textContent = gameSpeed;
        }

        function setMode(mode) {
            config.mode = mode;
            pauseTraining();
            
            if (mode === 'Dontlearn') {
                agent.dontlearn();
            } else {
                agent.dontlearn_enabled = true;
                agent.exploration_rate = 0.2;
            }
            
            document.getElementById('mode-display').textContent = mode;
            document.getElementById('status').textContent = `Mode ${mode} - Pr√™t`;
            updateButtonStates();
        }

        function runGameStep() {
            if (!game || !agent) return;

            const state = game.get_state();
            const action = agent.choose_action(state, config.mode !== 'Dontlearn');
            
            // Mettre √† jour la direction du serpent
            const directionMapping = {
                "UP": [-1, 0],
                "DOWN": [1, 0],
                "LEFT": [0, -1],
                "RIGHT": [0, 1]
            };
            game.snake_dir = directionMapping[action];

            const result = game.update();
            
            // Calculer la r√©compense
            let reward = -1;
            if (result === "Ate Green Apple") reward = 20;
            else if (result === "Ate Red Apple") reward = -10;
            else if (result === "Hit Snake Body") reward = -50;
            else if (result === "Game Over") reward = -100;

            // G√©rer les nouveaux objets
            agent.handle_new_objects(state, action, reward);

            // Apprentissage
            if (result !== "Game Over" && result !== "Hit Snake Body") {
                const next_state = game.get_state();
                if (config.mode !== 'Dontlearn') {
                    agent.learn(state, action, reward, next_state);
                    agent.decay_exploration();
                }
                game.steps += 1;
            }

            // Mettre √† jour l'affichage
            document.getElementById('action-chosen').textContent = action;
            updateDisplay();
            renderGame();

            // G√©rer la fin de partie
            if (result === "Game Over" || result === "Hit Snake Body") {
                lengthHistory.push(game.max_length_reached);
                pauseTraining();
                
                // Passer √† la session suivante
                currentSession++;
                if (currentSession <= totalSessions) {
                    setTimeout(() => {
                        agent.reset_history();
                        game.reset();
                        startTraining();
                    }, 1000);
                } else {
                    document.getElementById('status').textContent = 'Toutes les sessions termin√©es';
                    isTraining = false;
                }
                updateButtonStates();
            }
        }

        // =============================================================================
        // GESTION DES PARAM√àTRES
        // =============================================================================

        function updateSessionsValue() {
            const value = document.getElementById('sessions').value;
            document.getElementById('sessions-value').textContent = value;
            config.sessions = parseInt(value);
            totalSessions = config.sessions;
        }

        function updateSizeValue() {
            const value = document.getElementById('board-size').value;
            document.getElementById('size-value').textContent = value;
            config.boardSize = parseInt(value);
        }

        function updateGreenValue() {
            const value = document.getElementById('green-apples').value;
            document.getElementById('green-value').textContent = value;
            config.greenApples = parseInt(value);
        }

        function updateRedValue() {
            const value = document.getElementById('red-apples').value;
            document.getElementById('red-value').textContent = value;
            config.redApples = parseInt(value);
        }

        function loadModel() {
            const path = document.getElementById('model-path').value;
            if (path) {
                // Simulation du chargement d'un mod√®le
                alert(`Chargement du mod√®le depuis: ${path}\n(Cette fonctionnalit√© serait impl√©ment√©e avec une vraie API)`);
                setMode('Game');
            }
        }

        function saveModel() {
            const path = document.getElementById('model-path').value;
            if (path) {
                // Simulation de la sauvegarde d'un mod√®le
                alert(`Sauvegarde du mod√®le dans: ${path}\n(Cette fonctionnalit√© serait impl√©ment√©e avec une vraie API)`);
            }
        }

        // =============================================================================
        // GESTION DU CLAVIER POUR LE MODE MANUEL
        // =============================================================================

        document.addEventListener('keydown', (e) => {
            if (!manualMode || !game) return;

            const keyToDirection = {
                "ArrowUp": [-1, 0],
                "ArrowDown": [1, 0],
                "ArrowLeft": [0, -1],
                "ArrowRight": [0, 1]
            };

            if (keyToDirection[e.key]) {
                game.snake_dir = keyToDirection[e.key];
                const result = game.update();
                
                if (result === "Moved" || result === "Ate Green Apple" || result === "Ate Red Apple") {
                    game.steps += 1;
                }
                
                updateDisplay();
                renderGame();

                if (result === "Game Over" || result === "Hit Snake Body") {
                    manualMode = false;
                    document.getElementById('status').textContent = 'Game Over - Mode Manuel d√©sactiv√©';
                    updateButtonStates();
                }
            }
        });

        // =============================================================================
        // INITIALISATION
        // =============================================================================

        document.addEventListener('DOMContentLoaded', function() {
            initializeGame();
            
            // Initialiser les valeurs d'affichage
            updateSessionsValue();
            updateSizeValue();
            updateGreenValue();
            updateRedValue();
        });
    </script>
</body>
</html>